# JavaScript の歴史

## 参考

- [しまぶーの IT 大学「歴史から学ぶ JavaScript 前編。ECMAScript、CommonJS、モジュール、名前空間を知ろう」](https://www.youtube.com/watch?v=PuomDgRbllw&list=PLwM1-TnN_NN4SV6DEs4OtfA51Up6XzTfB&index=2&ab_channel=%E3%81%97%E3%81%BE%E3%81%B6%E3%83%BC%E3%81%AEIT%E5%A4%A7%E5%AD%A6)
- [しまぶーの IT 大学「歴史から学ぶ JavaScript 後編 ① Node.js とパッケージ管理システム npm」](https://www.youtube.com/watch?v=RdFE03K9B08&list=PLwM1-TnN_NN4SV6DEs4OtfA51Up6XzTfB&index=3&ab_channel=%E3%81%97%E3%81%BE%E3%81%B6%E3%83%BC%E3%81%AEIT%E5%A4%A7%E5%AD%A6)
- [しまぶーの IT 大学「歴史から学ぶ JavaScript 後編 ② IIFE・AMD モジュールとブラウザ向けパッケージ管理システム Bower」](https://www.youtube.com/watch?v=vuWAhqgRI3M&list=PLwM1-TnN_NN4SV6DEs4OtfA51Up6XzTfB&index=4&ab_channel=%E3%81%97%E3%81%BE%E3%81%B6%E3%83%BC%E3%81%AEIT%E5%A4%A7%E5%AD%A6)

## ECMAScript と JavaScript

歴史上の経緯から、異なるブラウザに対しても統一された使用で JavaScript が動作するようにしようと、1997 年に、国際的な標準化団体 Ecma International によって、ECMAScript の第 1 版が公開された。

2015 年には第 6 版が公開され、そのリリースからは年号が使われるようになった。そのため、ES6 の表記は誤りで、正確には ES2015 と言うべきである。2015 年以降は、使用策定プロセスが変更され、毎年リリースされるようになった。

ECMAScript とは JavaScript の中核となる言語仕様のことで、UI を操作するためのメソッドやプロパティが準備されたブラウザ上の JavaScript や、サーバサイドの言語である Node.js などの実行環境の違いには関係のないところで、どの実行環境でも共通な動作のみが定義されている。つまり、Node.js や ブラウザの違いを意識せずに ECMAScript を開発することはできる。ただし、実際には実装速に差があるため、コンパイルするか、その他のことに気をつける必要がある。

## Ajax と jQuery

2005 年頃から非同期通信を行うための Ajax（代表例は、マップの位置ごとにページをロードする必要がなくなった Google Maps）や jQuery の誕生で、一時期は不快なアニメーションや悪用によるウイルスの発生などから人気を落としていた JavaScript が再度復権するようになった。

## Server side JavaScript の動き

2009 年 1 月から、Mozilla のエンジニアが SeverJS というプロジェクトを立ち上げたが、ブラウザ上ではなく、新たにサーバサイドで使うには多くの API が不足していたので、そのような API を作っていく必要性が生じた。そこから、より広範囲の API を対象とすることを示すために、現在の CommonJS という名称（つまりプロジェクト名）に改名された。

## モジュール API

モジュールとは、javascript.info によると

> モジュールはただのファイルである。1 つのスクリプトは 1 つのモジュールである。モジュールは相互に読み込んだり、export と import (require) を使用して機能をやり取りしたり、あるモジュールの関数を別のモジュールから呼び出したりすることができます。

と説明されている。

JavaScript には名前空間 (namespace) は 1 つしかないため、変数名や関数名が被りバグの原因になるため、大規模なプロジェクトでは開発が困難になってしまう。

また、複数の JavaScript ファイル間の依存関係や読み込み順による問題でメンテンナンスが困難になってしまう状況があった。

そこで、

- 名前空間に関する問題を「モジュール」が
- 依存関係に関する問題を「パッケージ管理 (npm)」が

それぞれ解決することになった。

モジュールを用いることで、変数名や関数名について「よそはよそ、うちはうち」のスコープの概念が導入されることになり、JavaScript のモジュールは 1 ファイル単位、ファイル内の変数や関数は外部に影響を及ぼさないというルールによって、名前空間に関する問題を解決した  （ただし、ブラウザ上の JavaScript では、やはり名前空間は 1 つだけでモジュールの概念がないので、依然としてこのような問題は残り続けることになった）。

## Node.js の誕生と CommonJS

2009 年に Node.js が誕生した。はじめは CommonJS のモジュール API に準拠していた。しかし、CommonJS のコミュニティがうまく機能しなかったこともあり、Node.js は独自の進化を遂げ、CommonJS のプロジェクトはもう動いていない状態である。

## パッケージ管理システム

サーバサイドでモジュールが使われるようになると、次にパッケージ管理システムが求められるようになった。

パッケージとは、`package.json` で記述されたファイルやディレクトリのことで、共有したい機能の単位のことを意味する。1 ファイルのみで交際されることもあれば、ディレクトリ単位のこともある。

モジュールのおかげで名前空間の問題が解決されて、モジュールごとに機能が細かく分けられるようになり、更にいろいろな機能を組み合わせて便利なことができるようになってきた。そのように機能が細分化されたり、組み合わせられたりするようになると、今度はそれらを共有して使用するニーズが生まれるようになる。他のサーバサイド言語ではそのような要件は実現されている。

以上のような流れで、Node.js で色々なパッケージが開発されるようになると、そのパッケージのバージョンを管理したり、共有したりするためのシステムの必要性が生じたことで、「パッケージ管理システム」が登場することになる。

パッケージ管理システムには、次の 4 つの機能が含まれていると考えられる。

1. リポジトリの購読
2. パッケージのインストール・削除
3. 依存関係の解決
4. 設定管理

リポジトリの購読とは、ローカル環境にインストールしたパッケージを更新したり、パッケージを検索したりできることを言う（つまり、インターネット上やインストール CD 上のパッケージリポジトリを指定して、必要に応じてローカルのパッケージリストを更新したり、パッケージ名を検索して必要なパッケージを探したりできるということである）。

パッケージのインストール・削除とは、パッケージを指定してローカルにインストールしたり、反対にローカルから削除したりできることである。

依存関係の解決とは、パッケージに必要な別のパッケージを自動的にインストールしたり更新したりすることできることである。

設定管理とは、パッケージの設定スクリプトを適切に記述することで、上記の 1, 2, 3 を自動で行い、毎回手動でパッケージをインストールしたり更新したりする必要がなくなること、そしてチームでの環境を要因揃えられるようになることである。

実際に、あるパッケージを手動でインストールしようとすれば、そのパッケージが依存している他のパッケージをすべてインストールし、さらにそれらのパッケージが依存しているパッケージもすべてインストールして、... というように、非常に大変な作業になるので、そのようなパッケージのインストールや管理をよしなに行えるのがパッケージ管理システムの役割と言える。

Node.js のパッケージ管理システムが、`npm` (Node Package Manager) である。

`node_modules` というディレクトリに依存関係のパッケージがすべてインストールされる。

しかし、以上の話はすべてサーバサイドのもので、ブラウザの JS ではまだモジュールも使えなければ、npm のパッケージも使えない...。

## ブラウザ側 JS の動き

昔からブラウザ上の JS でもモジュールの概念の導入のために、下記のような IIFE（即時実行関数式）の使用による擬似的な名前空間を導入するようなことが模索されることもあったが、それだけでは不十分で、名前空間の問題も完全に解決されるわけではなかった。

```javascript
// 不自然な書き方にはなるが、変数 `foo` のスコープをプライベートにできる
(function () {
  var foo = "foo";
})();
foo; // foo is not defined
```

そこで、ブラウザでのモジュールの扱いを改善するために、2009 年頃に AMD という仕様が誕生し、その仕様を実装しているものとして Require JS というものが現れた。

今度は 2012 年にブラウザ向けパッケージ管理システムとして、Bower が誕生した。npm と似たようなことをブラウザ用 JS でできるというものである。

しかし、AMD 形式のモジュールはサーバ側の機能と互換性がなく、AMD 形式の構文は CommonJS 形式（例：require と export だけで書ける）と比較して冗長であることや、依存関係が膨大な場合のメンテナンスコストが高いことなど、色々なネガティブな側面が存在した。Bower も依然として色々な問題を抱えていた。

## ブラウザ向け JS に起きたパラダイムシフト

上記のように、様々な模索や努力が行われたブラウザ上の JS であるが、考え方を変えて、CommonJS 形式で書かれたものを事前にブラウザ向けに変換するという発想が生まれた。つまり、開発者が書いたコードと、実際にブラウザ上で動く（ランタイムの）コードが異なるものである、ということである。

事前にブラウザ向けに変換するものに、次の 2 つの概念がある。

- Bundle
- Compile

## Bundle

開発時は CommonJS モジュールに従って行い、モジュールの依存関係をに解決した上（これが Bundle）で単一ファイルに変換し、変換したコードをいつもどおり `script` タグで読み込むという流れが、Bundle の概念を用いたブラウザ向け JS の事前のプロセスである。

つまり、開発時には CommonJS (cjs) 形式で書かれた複数の JavaScript ファイルの集まり（実際には CSS や画像などを含むい色々を一緒に Bundle するのが一般的である）が、最終的には単一（設定によっては 2 つや 3 つになることもある）の JavaScript ファイルに集約されて動作するということである。

このような CommonJS 形式で書かれたものをブラウザ向けにバンドルするツールとして 2011 年に誕生したのが Browserify である。Browserify によって、すべての依存関係を束ねて（バンドルして）ブラウザで `require('module')` が使用可能になり、本来ブラウザ JS には定義されていない（Node.js には定義されている） `require` メソッドが使えるようになった。それによって、npm に存在した Node.js の便利なパッケージがブラウザ向けに移植される流れとなった。以上のような流れを経て、ブラウザ JS でも Bower ではなく、npm が主流になった。

2012 年に誕生した新たなバンドルツールである webpack が、Browserify よりも高機能で、上位互換的な位置付けとして認識されるようになり、現在でも webpack がブラウザ JS のバンドルツールの主流である。

## webpack

webpack とは、主に JS 向けではあるが、対応するローダーがあれば、HTML, CSS に加えその他の画像など、フロントエンドのアセットも含めて変換・束ねる（バンドルする）ことができるツールである。

webpack を用いることで、様々な種類のアセットや JS ファイルを、`.cjs` や `.hbs` など、本来ブラウザではそのまま動作しない種類のものも含めて、それらの依存関係を適切に解決した上で、依存関係のない `.js`, `.css`, `.jpg`, `.png` などのアセットとして変換・バンドルすることができる。

CJS 形式のモジュールをバンドルするのが Browserify で、JS に限らずなんでもバンドルするのが webpack であるというふうに両者の違いを認識していて問題ない。

また、webpack には "chunk" という概念が存在しており、多くの JS ファイルやフロントエンドアセットをバンドルすることでサイズが大きくなりがちなコードを、複数の chunk （塊）に分割 ("Code Splitting") し、実行時に必要に応じて非同期的にロードすることができるので、最初のロード時間を短縮することができ、パフォーマンスの向上につながった。

## EcmaScript の話に戻ると... (ES Modules)

以上のようなモジュールの仕様は、JavaScript の言語そのものがもつ言語仕様ではなく、その場その場で考案・実装された独自の仕様である。JavaScript の言語仕様として、そのようなモジュールの概念を導入しておくべきだということで、JavaScript の言語仕様の中核である EcmaScript (ES) が公式にサポートしたモジュールの概念が **"ES Modules"** である（例えば CommonJS 形式では `require` 文を用いていたのを ES 形式では正式に `import` 文を用いるようにした）。これで、ようやく辛く長いモジュール論争が終わりを告げた（しかし、IE など当時はほとんどのブラウザで、ES Modules をサポートしていなかった）。

## webpack と ES Modules

せっかく言語仕様としてモジュールの概念が使えるようになったのだから、独自の CommonJS 形式（`require` 構文）でコードを書くよりも、ES Modules に従った方法（`import` 構文）でコードを書きたいという需要が高まったところで、webpack が Version 2 で ES Modules をネイティブでサポートするようになった（ローダーがなくても ES Modules を読み込めるようになった。webpack、神...。）。つまり、webpack を用いることで、開発時は `import` 構文を用いてコードを書き、バンドル時に適切に変換されるということである。このようにして、webpack はますますモジュールバンドラとして確固たるポジションを築くこととなった。

また、ES Modules (ESM) は、現在では webpack を通じずとも、IE 以外のモダンブラウザと Node.js の Version 12 系以上では、標準で使用可能になっている。

## Compile

事前にブラウザ向けに変換する方法として、Bundle と Compile が存在することを上で説明し、Bundle の説明を長く行ってきたが、今度は Compile に話を移す。

Compile によって開発時にはブラウザでは動かない形式であるが、開発に便利な機能を使って効率的にコードを書きつつ、そこで書いたコードをブラウザで動くように変換（コンパイル）した後に、変換したコードをいつもどおり `script` タグで読み込むという流れが可能になる。

Bundle では、モジュールや依存関係の解決に焦点を当てていたのに対して、Compile では開発時に利用できる便利な機能を後で JS に変換することに焦点を当てている。

例えば、ES2015 の仕様では、新たに `let`, `const`, `class`, `Promise`, アロー関数、分割代入、スプレッド構文、テンプレート文字列などの、開発時には非常に有用な内容が多く追加されたが、IE に互換性がないこなどから、すぐに使えるわけではなった。しかし、それを解決するのがコンパイルの概念で、2014 年に誕生した Babel (6to5) というコンパイラは、ES2015 などの新しい仕様で書かれたコードを、従来の環境でも動くように古い JavaScript に変換することができるようになった。これによって、開発時には新しい EcmaScript の仕様の恩恵を受けつつ、従来環境でも動作することが保証できるようになった上、webpack の設定によって、Babel も一緒に使うことができるようになったので、モジュールが使え、依存関係も解決でき、さらに ES2015 の新機能まで使いながら開発できるということになり、急速に JavaScript が便利になっていった。

そして、事前にコンパイル（ビルド）することが、ブラウザ向け JS の常識となることで、React (`jsx`), Vue (`.vue`), TypeScript (`.ts`) などの多くの便利なパッケージが開発され、流行することになった。つまり、本来ブラウザで読み込めない形式であるはずの便利なパッケージが、ブラウザ上で実行する前に `.js` にコンパイルされることが前提となったことで利用可能になったということである。

これで晴れて、ブラウザ JSer にも天国のような環境が訪れた。

## 「事前に変換」というパラダイムシフト

従来は jQuery など、`script` タグで直接読み込んで動作するようなブラウザ側 JS の仕組みが使われていたのが、Bundle, Compile の概念で「事前に変換」することを前提とすることで、依存関係を解決してモジュールが使え、名前空間の問題も季にすることなく、ES の新機能や、TypeScript などのパッケージ、React や Vue などのその他の多くの JS フレームワークを使えるようになったことで衰退し、「事前に変換」というパラダイムシフトによって、ブラウザ側 JS の主流が大きく変わるきっかけとなった。

このパラダイムシフトを理解していることが、JavaScript の初級者と中級者を分ける境目である。

## 重要なキーワードまとめ

今まで多くの概念やキーワードが登場したので、歴史上の経緯で登場した現在はそれほど重要でないものを除いて、これから把握しておくべきものを列挙すると、以下のようである。

- Node.js
- パッケージ管理システム
- npm (package.json)
- 事前に変換 (Bundle, Compile)
- webpack
- Babel
- ES Modules
- ES2015 (ES2020)
- React, Vue
- TypeScript
